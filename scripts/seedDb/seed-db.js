const {
  getColonyNetworkClient,
  Extension,
  getExtensionHash,
  getLogs,
} = require('@colony/colony-js');
require('dotenv').config();
const { providers, BigNumber } = require('ethers');

const fetch = require('node-fetch');

const provider = new providers.JsonRpcProvider(
  'http://qa-cdapp.colony.io/rpc/',
);
const toNumber = (bigNumber) => BigNumber.from(bigNumber).toNumber();

const apiKey = process.env.AWS_APPSYNC_KEY;
const apiUrl = process.env.AWS_APPSYNC_GRAPHQL_URL;

const COLONY_CURRENT_VERSION_KEY = 'colony';

const networkClient = getColonyNetworkClient('gnosis', provider, {
  networkAddress: '0x6a05DD32860C1b5351B97b4eCAAbFbc60edb102f',
});

const CreateCurrentNetworkInverseFeeDocument = `
  mutation CreateCurrentNetworkInverseFee(
    $input: CreateCurrentNetworkInverseFeeInput!
  ) {
    createCurrentNetworkInverseFee(input: $input) {
      id
    }
  }
`;

const SetCurrentVersionDocument = `
  mutation SetCurrentVersion($input: SetCurrentVersionInput!) {
    setCurrentVersion(input: $input)
  }
`;
async function req({ query, variables }) {
  await fetch(apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': apiKey,
    },
    body: JSON.stringify({
      query,
      variables,
    }),
  });
}

const NETWORK_INVERSE_FEE_DATABASE_ID = 'networkInverseFee';

const SUPPORTED_EXTENSION_IDS = [
  Extension.OneTxPayment,
  Extension.VotingReputation,
  Extension.StakedExpenditure,
  Extension.StagedExpenditure,
  Extension.StreamingPayments,
];

const seedNetworkFee = async () => {
  const networkInverseFee = await networkClient.getFeeInverse();
  const convertedFee = networkInverseFee.toString();

  await req({
    query: CreateCurrentNetworkInverseFeeDocument,
    variables: {
      input: {
        id: NETWORK_INVERSE_FEE_DATABASE_ID,
        inverseFee: convertedFee,
      },
    },
  });
};

const mapLogToContractEvent = async (
  log,
  iface,
  // Additional properties to attach to the contract event
  additionalProperties,
) => {
  const { provider } = networkClient;
  const {
    transactionHash,
    logIndex,
    blockNumber,
    address: eventContractAddress,
  } = log;

  try {
    const block = await provider.getBlock(blockNumber);

    const { hash: blockHash, timestamp } = block;
    const parsedLog = iface.parseLog(log);

    return {
      ...parsedLog,
      blockNumber,
      transactionHash,
      logIndex,
      contractAddress: eventContractAddress,
      blockHash,
      timestamp,
      ...additionalProperties,
    };
  } catch (error) {
    /*
     * Silent Error
     *
     * This does not need to be loud since, at times, you'll map through a whole
     * lot of events which might not know how to interface with since they were
     * generated by other contracts
     */
    return null;
  }
};
const extensionVersion = {
  [Extension.OneTxPayment]: 4,
  [Extension.VotingReputation]: 9,
  [Extension.StakedExpenditure]: 4,
  [Extension.StagedExpenditure]: 1,
  [Extension.StreamingPayments]: 3,
};
const seedExtensionsVersions = async () => {
  SUPPORTED_EXTENSION_IDS.forEach(async (extensionId) => {
    const extensionHash = getExtensionHash(extensionId);

    await req({
      query: SetCurrentVersionDocument,
      variables: {
        input: {
          key: extensionHash,
          version: extensionVersion[extensionId],
        },
      },
    });
  });
};

const seedColoniesVersions = async () => {
  const version = await networkClient.getCurrentColonyVersion();

  await req({
    query: SetCurrentVersionDocument,
    variables: {
      input: {
        key: COLONY_CURRENT_VERSION_KEY,
        version: toNumber(version),
      },
    },
  });
};

const seedDB = async () => {
  await seedNetworkFee();
  await seedExtensionsVersions();
  await seedColoniesVersions();
  console.log('success');
};

seedDB();
